<html>
    <head>
        <title>Minecraft With Guns</title>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1DQEM7K2ZV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1DQEM7K2ZV');
</script>
</head>
    <style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
}

body {
  display: flex;
  align-items: center;
  justify-content: center;
}
.back-button {
    text-decoration: none;
    color: #00ff00;
    background-color: transparent;
    border: 1px solid #00ff00;
    padding: 10px 20px;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
}
.back-button {
  position: absolute;
  top: 20px;     /* Adjust the distance from the top */
  left: 20px;    /* Adjust the distance from the left */
}
.back-button:hover {
    background-color: #66ff66;
}
div {
  width: 100vw;
  height: 100vh;
  background-color: black; /* You can change the background color */
}
/* Add the canvas border styling */
canvas {
border: 2px solid #00ff00; /* Bright green border */
border-radius: 5px; /* Optional rounded corners */
}
    </style>
    <body>
        <div id="div" align="center" style="margin: auto;"><canvas id="canvas"></canvas></div>
    <script src="https://www.tinkerdoodle.cc/static/jquery-3.5.1.min.js"></script>
        <script src="https://www.tinkerdoodle.cc/ka/processing-ka.js"></script>
        <script>

var processingJS;            
            
new Processing("canvas", proc => {

    with (proc) {
    processingJS = proc;
        size(400, 400);
        angleMode = "degrees";
/////////////////        
//If you consent to not to flag this program of any reason other than plagiarism. This program is given AS IS. Mild violence warning along with jumpscares.
var I_agree = true;
/*
Now why did I accidentally click save?
I guess I have to do a Pre-Release sooner or later. Whatever.
Well, the full-release is coming up soon.
Sub at tinyurl.com/sub2thrifty to be notified.
In progress:
{ddd
    Making walls to place down, and other blocks that do stuff. This is turning into Birds-Eye MineCraft with Guns.
}
Bugs:
{
    You get stuck in a tree.
    The game occasionally glitches out instantly.
    Blobs like to hide under rocks and trees (They get stuck until you come.)
}
Updates:
{
    Delagged by making coins dissapear if too far.
    Hacked mode.
    Nerfed blobs, delagged, flashlight effect.
    VERY big blobs. Evil.
    Healing blobs (Help you!) Don't give any money, but heal you. Very cute.
    BLOBS! (HOSTILE)
    + and - keys to zoom in and out.
    Scroll to zoom in and out
    Sunrise+Sunset
    Nighttime!
    More starting money (TOO much.)
    Added seeing range (Sniper is the all-seeing.)
    Added range (Some bullets splat closer, some farther.)
    Fixed a HUGE bug.
    Shock buffed.
    Bullets triger mines.
    SHOCK ADDED!
    Organized code.
    Implemented crate collisions!
    When you level up, you get coins in the middle now!
    Now you get damaged by splats (More likely, now), and you can get damaged by your own bullets from a rebound off of the arena walls (Newly added), or treading on your own mine. XD
    Rocks added, XP bar added, and some minor bug fixes.
    Fume nerfed by like a LOT.
    You can suicide by pressing "O".
    Explosions can harm you now.
    Chickens won't run if you under tree. Dumb chickens.
    Now you can buy guns!
    Added frameRate and chicken health regen along with money.
    Now you can switch guns!
    Tree collision fixed!
    Trees added!
    Chickens more chicken like now!
    Chickens added!
    Arena more grass like.
}
*/
frameRate(60);
//I encourage cheating by changing this so you can test more guns out easily.
var money = 100;
var hacked = false;
//Nighttime!
var night = true;
//Code
//{
//Misc variables. {
var dn = -19;
var ss = 0.01;
//Array holding your current coordinates.
var coordinates = [200, 200];
//Vector telling you what to move.
var speed = [0, 0];
//This is the current arena size.
var arena_Size = 1200;
//This sets your current character, or skin (Change this as you wish)
var current_character = 1;
//This sets your current gun. (Change this as you wish)
var current_gun = 0;
//This array contains the bullets.
var bullets = [];
//A loading gun variable.
var loading = false;
//Array holding the booleans of whether you are moving in a direction.
var movement = [false, false, false, false];
var crates = [];
var coins = [];
var chickens = [];
var blobs = [];
var blocks = [];
var trees = [];
var rocks = [];
var woods = 0;
var wood = [];
var f = createFont("cursive");
var xp = 0;
var next_xp = 10;
var xpw = 0;
var tier = 0;
var tiers = ["Private", "Apprentice", "Hunter", "Stalker", "Killer", "Vanquisher", "Diabolical", "God", "Not Applicable", "MONSTER", "How the heck did you get this far?"];
textFont(f);
//}
//Collision function that returns the vectors we need
var collide = function(x1, y1, x2, y2, vx, vy, s1, s2) {
    _clearLogs();
    var a = (x1 - x2) / (y1 - y2);
    var v1x = (a * vy + a * a * vx) / (a * a + 1);
    var v1y = (vy + a * vx) / (a * a + 1);
    var v2x = (vx - a * vy) / (a * a + 1);
    var v2y = (a * a * vy - a * vx) / (a * a + 1);
    if (dist(x1 - v1x / 2 + v2x, x2, y1 - v1y / 2 + v2y, y2) > (s1 + s2) / 2) {
        return [(-v1x / 2 + v2x), (-v1y / 2 + v2y)];
    } else {
        return [(-v1x + v2x), (-v1y + v2y)];
    }
};
//Returns what side was collided with in the case of a rectangle.
var side = function(x1, y1, x2, y2, s, s2) {
    if (x1 + s2 > x2 & y1 + s2 > y2 & x1 < x2 + s & y1 < y2 + s) {
        if (y1 - y2 + s2 / 2 <= x1 - x2) {
            if (y1 - y2 + s2 / 2 <= x2 - x1 + s) {
                return "up";
            } else {
                return "right";
            }
        } else {
            if (y1 - y2 + s2 / 2 <= x2 - x1 + s) {
                return "left";
            } else {
                return "down";
            }
        }
    }
    return false;
};
//Reverse constrain. Very useful.
var rev_const = function(x1, s1, x2, s2) {
    if (x1 + s1 > x2 & x1 < x2 + s2 / 2) {
        return x2 - s1;
    } else if (x1 < x2 + s2 & x1 > x2 + s2 / 2) {
        return x2 + s2;
    } else {
        return x1;
    }
};
//The function for drawing the spawner.
var spawn = function(x, y, s) {
    noStroke();
    fill(200, 200, 200);
    ellipse(x, y, s * 19 / 10, s * 19 / 10);
    for (var i = s; i < 2 * s; i++) {
        fill(0, 255, 255, i / 100);
        ellipse(x, y, i, i);
    }
    strokeWeight(2.5);
    stroke(60, 60, 60);
    fill(0, 255, 255, 127.5);
    ellipse(x, y, s, s);
    strokeWeight(5);
    stroke(0, 255, 255);
    ellipse(x, y, s / 2, s / 2);
};
//These functions draw the characters (Also known as skins.)
//{
//"Default."
var basic = function(x, y, s) {
    noStroke();
    fill(255, 255, 255);
    ellipse(x, y, s, s);
    stroke(0, 0, 0);
    strokeWeight(2.5);
    point(x + 5, y + 5);
    point(x - 5, y + 5);
};
//Boo!
var ghost = function(x, y, s) {
    noStroke();
    fill(0, 255, 255, 200);
    ellipse(x, y, s, s);
    stroke(255, 255, 255);
    strokeWeight(5);
    point(x + 5, y + 5);
    point(x - 5, y + 5);
};
//Nope, still invisible.
var camo = function(x, y, s) {
    stroke(0, 0, 0);
    strokeWeight(0.5);
    fill(230, 230, 230, 100);
    ellipse(x, y, s, s);
    stroke(60, 60, 60);
    strokeWeight(5);
    point(x + 5, y + 5);
    point(x - 5, y + 5);
};
//}
//This array contains all of the characters.
var characters = [
    [25, basic, 2.5, 100, 100, 1],
    [25, ghost, 3, 75, 75, 2.5],
    [25, camo, 1, 150, 150, 1]
];
//These functions draw the guns or the bullets, depending on what "t" is.
//{
//"The standard."
var pistol = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(0, 0, 0);
        rect(x, y, s / 5, s / 2);
        rect(x + s / 32, y + s / 4, s / 10, s / 2);
    } else if (t === "bullet") {
        stroke(0, 0, 0);
        strokeWeight(s);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(0, 0, 0, n * 255 / 100);
        ellipse(x, y, s / 4, s / 4);
    }
};
//SPRAYAR!
var machine = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(60, 60, 60);
        rect(x, y, s / 8, s / 2);
        rect(x + s / 64, y + s / 8, s / 16, s / 2);
        rect(x - s / 16, y + s / 16, s / 16, s / 4);
    } else if (t === "bullet") {
        stroke(255, 230, 0);
        strokeWeight(s);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(255, 200, 0, n * 255 / 500);
        ellipse(x, y, s / 5, s / 5);
    }
};
//Kabloosh.
var cannon = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        rect(x - s / 8, y, s / 4, s / 2);
        fill(0, 0, 0);
        rect(x + s / 16, y + s / 16, s / 8, s / 4);
        fill(80, 80, 80);
        ellipse(x, y, s / 4, s / 8);
        fill(0, 0, 0);
        ellipse(x, y + s / 2, s / 4, s / 8);
    } else if (t === "bullet") {
        stroke(0, 0, 0);
        strokeWeight(s * 4);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(255, 200, 0, n * 255 / 250);
        ellipse(x, y, 200 - n / 5 + 25, 200 - n / 5 + 25);
    }
};
//SnIpEd!
var sniper = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        rect(x, y + s / 16, s / 8, s / 2);
        fill(80, 80, 80);
        rect(x + s / 32, y + s / 16, s / 16, 2 * s / 3);
        fill(0, 0, 0);
        rect(x + s / 8, y + s / 8, s / 8, s / 4);
    } else if (t === "bullet") {
        stroke(255, 255, 0);
        strokeWeight(s);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(255, 0, 0, n * 255 / 500);
        ellipse(x, y, s / 2, s / 2);
    }
};
//Gassy
var fume = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        ellipse(x + s / 16, y + s / 16, s / 3, s / 3);
        rect(x + s / 16, y - s / 4, s / 2, s / 4, s / 8);
        strokeWeight(s / 8);
        stroke(0, 200, 0);
        line(x + s / 4, y - s / 8, x + s / 16, y + s / 16);
    } else if (t === "bullet") {
        stroke(0, 200, 0, 127.5);
        strokeWeight(s * 3);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(255, 0, 0, n * 255 / 500);
        ellipse(x, y, s / 2, s / 2);
    }
};
//H2O
var water = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        ellipse(x + s / 16, y + s / 16, s / 4, s / 2);
        fill(100, 100, 100);
        ellipse(x + s / 16, y + s / 4, s / 4, s / 4);
        fill(0, 0, 0);
        ellipse(x + s / 16, y + s / 4, s / 16, s / 16);
        fill(0, 100, 250, 127.5);
        stroke(80, 80, 80);
        strokeWeight(s / 32);
        rect(x + s / 16, y - s / 4, s / 2, s / 4, s / 8);
        strokeWeight(s / 16);
        if (mouseIsPressed) {
            stroke(0, 100, 250);
        } else {
            stroke(255, 255, 255, 100);
        }
        line(x + s / 4, y - s / 8, x + s / 16, y + s / 16);
    } else if (t === "bullet") {
        stroke(0, 100, 250, 127.5);
        strokeWeight(s * 2);
        point(x, y);
    } else if (t === "hit") {
        noStroke();
        fill(0, 100, 250, n * 255 / 1000);
        ellipse(x, y, 2 * s / 3, 2 * s / 3);
    }
};
var mine = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        ellipse(x + s / 16, y + s / 16, s / 3, s / 3);
        fill(255, 0, 0);
        ellipse(x + s / 16, y + s / 16, s / 8, s / 8);
        fill(100, 100, 100);
        rect(x + s / 16, y - s / 4, s / 2, s / 3, s / 4);
    } else if (t === "bullet") {
        strokeWeight(2.5);
        stroke(60, 60, 60);
        fill(80, 80, 80);
        ellipse(x, y, 3 * s, 3 * s);
        noStroke();
        fill(255, 0, 0, 255 * round(random(0, 1)));
        ellipse(x, y, s, s);
    } else if (t === "hit") {
        noStroke();
        fill(255, 200, 0, n * 255 / 250);
        ellipse(x, y, 100 - n / 10 + 25, 100 - n / 10 + 25);
    }
};
var shock = function(x, y, s, t, n) {
    if (t === "gun") {
        noStroke();
        fill(80, 80, 80);
        rect(x, y + s / 16, s / 6, s / 2, s / 16);
        fill(0, 255, 255, 200);
        stroke(0, 255, 255);
        strokeWeight(1);
        rect(x + s / 32, y + s / 4, s / 16, s / 2, s / 16);
    } else if (t === "bullet") {
        noStroke();
        fill(0, 255, 255, random(100, 255));
        var g = random(3 / 2, 2);
        ellipse(x, y, s * g, s * g);
    } else if (t === "hit") {
        noStroke();
        fill(0, 255, 255, n * 50 / 250);
        ellipse(x, y, 200 - n / 5 + 25, 200 - n / 5 + 25);
    }
};
//}
//This array contains all of the guns.
//Size, type, Bullet count, Shoot delay, Shoot delay manager, Bullet speed, Max bullet count, Spread, Recoil, Damage, Area of area damage, area damage, range
var guns = [
    [25, pistol, 8, 25, 0, 10, 8, 1, 0.5, 12.5, 0, 0, true, 0, 250, 20, 1, 1],
    [62.5, machine, 100, 4, 0, 8, 100, 2, 0.25, 2, 0, 0, false, 300, 300, 40, 0.9, 0.9],
    [75, cannon, 3, 100, 0, 6, 3, 0, 5, 25, 75, 37.5, false, 500, 400, 25, 1, 1],
    [62.5, sniper, 10, 75, 0, 20, 10, 0, 0.5, 40, 0, 0, false, 500, 200, 100, 0.5, 0.5],
    [50, fume, 150, 1, 0, 2, 150, 1.25, 0.01, 0.1, 0, 0, false, 400, 100, 1000, 1, 1],
    [50, water, 200, 1, 0, 4, 200, 0.5, 0.05, 2, 25, 1, false, 400, 100, 40, 0.9, 0.9],
    [50, mine, 10, 25, 0, 0, 10, 0, 0, 5, 50, 50, false, 400, 100, 1000, 0.9, 0.9],
    [50, shock, 8, 1, 0, 10, 8, 0.1, 0.1, 2.5, 100, 12.5, false, 600, 300, 30, 0.75, 0.75]
];
var splats = [];
//Splat function
var splat = function(j) {
    for (var k = 0; k < crates.length; k++) {
        if (dist(bullets[j][1] + coordinates[0], bullets[j][2] + coordinates[1], crates[k][0] + coordinates[0] + 12.5, crates[k][1] + coordinates[1] + 12.5) <= bullets[j][7]) {
            crates[k][2] -= bullets[j][6];
        }
    }
    for (var k = 0; k < chickens.length; k++) {
        if (dist(bullets[j][1], bullets[j][2], chickens[k][0], chickens[k][1]) <= bullets[j][7]) {
            chickens[k][4] -= bullets[j][6];
        }
    }
    for (var k = 0; k < blobs.length; k++) {
        if (dn >= 1 || blobs[k][13]) {
            if (dist(bullets[j][1], bullets[j][2], blobs[k][0], blobs[k][1]) <= bullets[j][7]) {
                blobs[k][5] -= bullets[j][6];
            }
        }
    }
    for (var k = 0; k < trees.length; k++) {
        if (dist(bullets[j][1], bullets[j][2], trees[k][0], trees[k][1]) <= bullets[j][7]) {
            trees[k][3] -= bullets[j][6];
        }
    }
    if (dist(bullets[j][1] + coordinates[0], bullets[j][2] + coordinates[1], 200, 200) <= 12.5 + bullets[j][7]) {
        characters[current_character][3] -= bullets[j][6];
    }
    if (bullets[j][0] !== fume) {
        splats.push([bullets[j][1], bullets[j][2], bullets[j][0], 500]);
        bullets.splice(j, 1);
        return;
    }
    return;
    //break;
};
//This array holds all of the bullets.
var bullets = [];
//Draws your current character, along with your gun, health and stat bars.
var draw_Character = function() {
    pushMatrix();
    translate(200, 200);
    rotate(atan2(mouseY - 200, mouseX - 200) - 90);
    translate(-200, -200);
    characters[current_character][1](200, 200, characters[current_character][0]);
    guns[current_gun][1](185, 195, guns[current_gun][0], "gun");
    popMatrix();
    stroke(255, 255, 255);
    strokeWeight(2.5);
    fill(0, 0, 0, 127.5);
    rect(180, 165, 40, 5, 25);
    fill(255, 175, 0);
    rect(180, 165, 40 * guns[current_gun][2] / guns[current_gun][6], 5, 25);
    fill(0, 0, 0, 127.5);
    rect(180, 175, 40, 5, 25);
    fill(255, 0, 127.5);
    rect(180, 175, 40 * guns[current_gun][4] / guns[current_gun][3], 5, 25);
};
//Manages your XP.
var manage_xp = function() {
    if (xp / next_xp >= 1) {
        for (var i = 0; i < next_xp / 2 + 1; i++) {
            coins.push([random(-25, 25), random(-25, 25)]);
        }
        xp -= next_xp;
        xpw -= next_xp;
        next_xp *= 2;
        tier++;
    }
    if (xp < xpw) {
        xp += next_xp / 500;
    }
};
//This makes you regain health and die.
var manage_health = function() {
    if (characters[current_character][3] / characters[current_character][4] < 1) {
        characters[current_character][3] += characters[current_character][5] / 25;
    }
    if (characters[current_character][3] / characters[current_character][4] > 1) {
        characters[current_character][3] = characters[current_character][4];
    }
    if (characters[current_character][3] <= 0) {
        characters[current_character][3] = characters[current_character][4];
        coordinates = [200, 200];
        for (var i = 0; i < bullets.length; i++) {
            splat(i);
        }
    }
};
//This makes the gun's reload go up if it is not at max.
var manage_gun_reload = function() {
    if (guns[current_gun][4] < guns[current_gun][3]) {
        guns[current_gun][4]++;
    }
};
//Bounces bullets.
var bounce_bullets = function(i) {
    if (bullets[i][1] <= -arena_Size / 2 || bullets[i][2] <= -arena_Size / 2 || bullets[i][1] >= arena_Size / 2 || bullets[i][2] >= arena_Size / 2) {
        if (bullets[i][0] === fume) {
            bullets.splice(i, 1);
            return;
        } else if (bullets[i][1] <= -arena_Size / 2) {
            bullets[i][1] = -arena_Size / 2;
            bullets[i][3] = abs(bullets[i][3]);
        } else if (bullets[i][1] >= arena_Size / 2) {
            bullets[i][1] = arena_Size / 2;
            bullets[i][3] = -abs(bullets[i][3]);
        } else if (bullets[i][2] <= -arena_Size / 2) {
            bullets[i][2] = -arena_Size / 2;
            bullets[i][4] = abs(bullets[i][4]);
        } else if (bullets[i][2] >= arena_Size / 2) {
            bullets[i][2] = arena_Size / 2;
            bullets[i][4] = -abs(bullets[i][4]);
        }
    }
};
//Actually draws the bullets and moves them according to the vector that determines their movement.
var manage_bullets = function() {
    for (var i = 0; i < bullets.length; i++) {
        //Draws bullets.
        bullets[i][0](bullets[i][1] + coordinates[0], bullets[i][2] + coordinates[1], 5, "bullet");
        //Moves bullets.
        bullets[i][1] += bullets[i][3];
        bullets[i][2] += bullets[i][4];
        bounce_bullets(i);
        if (dist(bullets[i][1] + coordinates[0], bullets[i][2] + coordinates[1], 200, 200) <= 10) {
            characters[current_character][3] -= bullets[i][5];
            splat(i);
            break;
        }
        //Bullets trigger mines.
        for (var j = 0; j < bullets.length; j++) {
            if (dist(bullets[i][1], bullets[i][2], bullets[j][1], bullets[j][2]) <= 10) {
                if (bullets[i][0] === mine & bullets[j][0] !== mine) {
                    splat(j);
                    splat(i);
                }
            }
        }
        if (bullets[i][9] >= bullets[i][8]) {
            splat(i);
        } else {
            bullets[i][9]++;
        }
    }
};
//Everything in the backdrop
var grid = function() {
    background(126, 200, 80);
    noStroke();
    fill(0, 0, 0, 255 * constrain(dn, 0, 1));
    rect(-1000, -1000, 4000, 4000);
    fill(126, 200, 80);
    stroke(100, 0, 0);
    strokeWeight(5);
    rect(-arena_Size / 2 + coordinates[0], -arena_Size / 2 + coordinates[1], arena_Size, arena_Size, 5);
    strokeWeight(5);
    stroke(60, 0, 0, 100);
    for (var i = -arena_Size / 2 + 25; i < arena_Size / 2; i += 50) {
        for (var j = -arena_Size / 2 + 25; j < arena_Size / 2; j += 50) {
            if (dist(i + coordinates[0], j + coordinates[1], 200, 200) <= 400 / guns[current_gun][16]) {
                point(i + coordinates[0], j + coordinates[1]);
            }
        }
    }
    spawn(coordinates[0], coordinates[1], 100);
};
//Moves player according to key pressed.
var move_player = function() {
    if (movement[0] === true) {
        speed[1] += characters[current_character][2] / 10;
    }
    if (movement[1] === true) {
        speed[0] += characters[current_character][2] / 10;
    }
    if (movement[2] === true) {
        speed[1] -= characters[current_character][2] / 10;
    }
    if (movement[3] === true) {
        speed[0] -= characters[current_character][2] / 10;
    }
};
//Movement function
var move = function() {
    for (var i = 0; i < speed.length; i++) {
        coordinates[i] += speed[i];
        speed[i] *= 0.95;
        if (coordinates[i] > arena_Size / 2 + (200 - characters[current_character][0] / 2)) {
            coordinates[i] = arena_Size / 2 + (200 - characters[current_character][0] / 2);
            speed[i] = -abs(speed[i] * 0.1);
        }
        if (coordinates[i] < -arena_Size / 2 + (200 + characters[current_character][0] / 2)) {
            coordinates[i] = -arena_Size / 2 + (200 + characters[current_character][0] / 2);
            speed[i] = abs(speed[i] * 0.1);
        }
    }
    move_player();
};
//Shooting function
var shoot = function() {
    //MousePressed shooting
    if (mouseIsPressed & loading === false) {
        if (guns[current_gun][2] > 0 & guns[current_gun][4] === guns[current_gun][3]) {
            bullets.push([guns[current_gun][1], 200 - coordinates[0] - (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * 12.5, 200 - coordinates[1] + (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * 12.5 + random(-guns[current_gun][7], guns[current_gun][7]), (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][5] + random(-guns[current_gun][7], guns[current_gun][7]), (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][5], guns[current_gun][9], guns[current_gun][11], guns[current_gun][10], guns[current_gun][15], 0]);
            guns[current_gun][4] = 0;
            guns[current_gun][2]--;
            speed[0] += (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][8];
            speed[1] += (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][8];
        }
    }
    //Space shooting.
    if (keyIsPressed & String(key) === " " & loading === false) {
        if (guns[current_gun][2] > 0 & guns[current_gun][4] === guns[current_gun][3]) {
            bullets.push([guns[current_gun][1], 200 - coordinates[0] - (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * 12.5, 200 - coordinates[1] + (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * 12.5 + random(-guns[current_gun][7], guns[current_gun][7]), (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][5] + random(-guns[current_gun][7], guns[current_gun][7]), (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][5], guns[current_gun][9], guns[current_gun][11], guns[current_gun][10], guns[current_gun][15], 0]);
            guns[current_gun][4] = 0;
            guns[current_gun][2]--;
            speed[0] += (mouseX - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][8];
            speed[1] += (mouseY - 200) / dist(mouseX, mouseY, 200, 200) * guns[current_gun][8];
        }
    }
    //Reload can't be negative.
    if (guns[current_gun][2] < 0) {
        guns[current_gun][2] = 0;
    }
};
//Loading function.
var load = function() {
    if (guns[current_gun][2] < guns[current_gun][6] & loading === true) {
        guns[current_gun][2] += guns[current_gun][6] / guns[current_gun][14];
    }
    if (guns[current_gun][2] >= guns[current_gun][6]) {
        loading = false;
    }
};
//Makes screen red if you have low health
var redden = function() {
    if (characters[current_character][3] / characters[current_character][4] <= 0.25) {
        fill(0, 0, 0, 0);
        strokeWeight(1);
        for (var i = 400; i > 0; i--) {
            stroke(255, 0, 0, (255 - (255 - i / 5)) * (0.25 - characters[current_character][3] / characters[current_character][4]) * 7.5);
            rect((400 - i) / 2, (400 - i) / 2, i, i);
        }
    }
};
//Trees
//{
//Spawns trees.
for (var i = 0; i < random(arena_Size / 100, arena_Size / 50); i++) {
    trees.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(100, 200), 100, 0]);
}
//Draws trees.
var draw_tree = function(x, y, s) {
    noStroke();
    fill(0, 100, 0, 200);
    //ellipse(x, y, s, s);
    ellipse(x - s / 4, y - s / 8, s / 2, s / 2);
    ellipse(x + s / 16, y + s / 3, s / 3, s / 3);
    ellipse(x + s / 8, y - s / 4, s / 2, s / 2);
    ellipse(x + s / 8, y + s / 4, s / 4, s / 4);
    ellipse(x + s / 4, y + s / 16, s / 2, s / 2);
    ellipse(x - s / 4, y, s / 3, s / 3);
    ellipse(x - s / 4, y + s / 4, s / 2, s / 2);
    ellipse(x, y + s / 4, s / 3, s / 3);
    fill(60, 0, 0);
    ellipse(x, y, s / 4, s / 4);
};
//Manages trees.
var manage_trees = function() {
    for (var i = 0; i < trees.length; i++) {
        if (dist(trees[i][0] + coordinates[0], trees[i][1] + coordinates[1], 200, 200) <= 400 / guns[current_gun][16]) {
            if(trees[i][4] >= 0) {
                trees[i][4]--;
                draw_tree(trees[i][0] + coordinates[0]+random(-2.5, 2.5), trees[i][1] + coordinates[1]+random(-2.5, 2.5), trees[i][2]);
            }
            else {
                draw_tree(trees[i][0] + coordinates[0], trees[i][1] + coordinates[1], trees[i][2]);
            }
            //Player with tree collide.
            if (dist(trees[i][0] + coordinates[0], trees[i][1] + coordinates[1], 200, 200) <= trees[i][2] / 8 + 12.5) {
                trees[i][4] = 10;
                trees[i][3] -= 2.5;
                speed = collide(200, 200, trees[i][0] + coordinates[0], trees[i][1] + coordinates[1], speed[0], speed[1], trees[i][2] / 4, 25);
            }
        }
        //Chicken with tree collide.
        for (var j = 0; j < chickens.length; j++) {
            if (dist(trees[i][0], trees[i][1], chickens[j][0], chickens[j][1]) <= trees[i][2] / 8 + chickens[j][5] / 2) {
                chickens[j][2] = collide(chickens[j][0], chickens[j][1], trees[i][0], trees[i][1], chickens[j][2], chickens[j][3], trees[i][8] / 4, chickens[j][5])[0];
                chickens[j][3] = collide(chickens[j][0], chickens[j][1], trees[i][0], trees[i][1], chickens[j][2], chickens[j][3], trees[i][8] / 4, chickens[j][5])[1];
            }
        }
        for (var j = 0; j < blobs.length; j++) {
            if (dist(trees[i][0], trees[i][1], blobs[j][0], blobs[j][1]) <= trees[i][2] / 8 + blobs[j][2] / 2) {
                blobs[j][3] = collide(blobs[j][0], blobs[j][1], trees[i][0], trees[i][1], blobs[j][3], blobs[j][4], trees[i][8] / 4, blobs[j][2])[0];
                blobs[j][4] = collide(blobs[j][0], blobs[j][1], trees[i][0], trees[i][1], blobs[j][3], blobs[j][4], trees[i][8] / 4, blobs[j][2])[1];
            }
        }
        //Bullet with tree splat.
        for (var j = 0; j < bullets.length; j++) {
            if (dist(bullets[j][1], bullets[j][2], trees[i][0], trees[i][1]) <= 5 + trees[i][2] / 8) {
                trees[i][3] -= bullets[j][5];
                trees[i][4] = 10;
                splat(j);
            }
        }
        if(trees[i][3] <= 0) {
            for(var k = 0; k < 10; k++) {
                wood.push([trees[i][0]+random(-25, 25), trees[i][1]+random(-25, 25)]);
            }
            trees.splice(i, 1);
            trees.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(100, 200), 100]);
        }
    }
};
//Checks if under tree.
var under_tree = function() {
    for (var i = 0; i < trees.length; i++) {
        if (dist(trees[i][0] + coordinates[0], trees[i][1] + coordinates[1], 200, 200) <= trees[i][2] / 2) {
            return true;
        }
    }
    return false;
};
//}
//Wood
//{
var draw_wood = function(x, y, s) {
    stroke(60, 0, 0);
    strokeWeight(5);
    fill(100, 0, 0);
    rect(x, y, s, s, s/4);
};
var manage_wood = function() {
    for(var i = 0; i < wood.length; i++) {
        draw_wood(wood[i][0]+coordinates[0], wood[i][1]+coordinates[1], 15);
        if (dist(wood[i][0] + coordinates[0], wood[i][1] + coordinates[1], 200, 200) <= 50) {
            wood[i][0] += (200 - (wood[i][0] + coordinates[0])) / dist(wood[i][0] + coordinates[0], wood[i][1] + coordinates[1], 200, 200) * 5;
            wood[i][1] += (200 - (wood[i][1] + coordinates[1])) / dist(wood[i][0] + coordinates[0], wood[i][1] + coordinates[1], 200, 200) * 5;
        }
        if (dist(wood[i][0] + coordinates[0], wood[i][1] + coordinates[1], 200, 200) <= 16) {
            wood.splice(i, 1);
            woods++;
        }
        else if (dist(wood[i][0] + coordinates[0], wood[i][1] + coordinates[1], 200, 200) >= 400) {
            wood.splice(i, 1);
        }
    }
};
//}
//Blocks
//{
var wall = function() {
    
};
//}
//Rocks
//{
//Spawns rocks.
for (var i = 0; i < random(arena_Size / 100, arena_Size / 50); i++) {
    var banana = [random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(100, 200)];
    for (var j = 0; j < 4; j++) {
        rocks.push([banana[0] + random(-25, 25), banana[1] + random(-25, 25), random(100, 200)]);
    }
}
//Draws a rock.
var draw_rock = function(x, y, s) {
    fill(100, 100, 100);
    strokeWeight(2.5);
    stroke(80, 80, 80);
    ellipse(x, y, s / 4, s / 4);
};
//Manages rocks.
var manage_rocks = function() {
    for (var i = 0; i < rocks.length; i++) {
        draw_rock(rocks[i][0] + coordinates[0], rocks[i][1] + coordinates[1], rocks[i][2]);
        //Rock with player collide.
        if (dist(rocks[i][0] + coordinates[0], rocks[i][1] + coordinates[1], 200, 200) <= rocks[i][2] / 8 + 12.5) {
            speed = collide(200, 200, rocks[i][0] + coordinates[0], rocks[i][1] + coordinates[1], speed[0], speed[1], rocks[i][2] / 4, 25);
        }
        //Rock with chicken collide.
        for (var j = 0; j < chickens.length; j++) {
            if (dist(rocks[i][0], rocks[i][1], chickens[j][0], chickens[j][1]) <= rocks[i][2] / 8 + chickens[j][5] / 2) {
                chickens[j][2] = collide(chickens[j][0], chickens[j][1], rocks[i][0], rocks[i][1], chickens[j][2], chickens[j][3], rocks[i][8] / 4, chickens[j][5])[0];
                chickens[j][3] = collide(chickens[j][0], chickens[j][1], rocks[i][0], rocks[i][1], chickens[j][2], chickens[j][3], rocks[i][8] / 4, chickens[j][5])[1];
            }
        }
        for (var j = 0; j < blobs.length; j++) {
            if (dist(rocks[i][0], rocks[i][1], blobs[j][0], blobs[j][1]) <= rocks[i][2] / 8 + blobs[j][2] / 2) {
                blobs[j][3] = collide(blobs[j][0], blobs[j][1], rocks[i][0], rocks[i][1], blobs[j][3], blobs[j][4], rocks[i][8] / 4, blobs[j][2])[0];
                blobs[j][4] = collide(blobs[j][0], blobs[j][1], rocks[i][0], rocks[i][1], blobs[j][3], blobs[j][4], rocks[i][8] / 4, blobs[j][2])[1];
            }
        }
        //Bullet with rock collide.
        for (var j = 0; j < bullets.length; j++) {
            if (dist(bullets[j][1], bullets[j][2], rocks[i][0], rocks[i][1]) <= 5 + rocks[i][2] / 8) {
                splat(j);
            }
        }
    }
};
//}
//CHICKEN STUFF!
//{
var Speed_of_chickens = 0.5;
//Draws a chicken.
var draw_chicken = function(x, y, s, l, z) {
    fill(0, 0, 0, 100);
    noStroke();
    ellipse(x, y, (s / 2 + 5) * 2, (s / 2 + 5) * 2);
    fill(120, 67, 33);
    noStroke();
    ellipse(x, y, s, s / 2);
    pushMatrix();
    translate(x - s / 16, y - s / 4);
    rotate(constrain(l * 50, 15, 80));
    translate(-x + s / 16, -y + s / 4);
    ellipse(x - s / 16, y - s / 4, s / 2, s / 4);
    popMatrix();
    pushMatrix();
    translate(x - s / 16, y + s / 4);
    rotate(-constrain(l * 50, 15, 80));
    translate(-x + s / 16, -y - s / 4);
    ellipse(x - s / 16, y + s / 4, s / 2, s / 4);
    popMatrix();
};
//Draws the chicken's health bar.
var chicken_health = function(x, y, s, z) {
    stroke(255, 255, 255);
    strokeWeight(2.5);
    fill(0, 0, 0, 127.5);
    rect(x - s / 2 - s / 4, y - s, s + s / 2, s / 4, s / 16);
    fill(255 - z * 255 / 50, z * 255 / 50, 0);
    rect(x - s / 2 - s / 4, y - s, (s + s / 2) * z / 50, s / 4, s / 16);
};
//Constrains the chicken.
var constrain_chicken = function(i) {
    //Constrains the chicken in the arena.
    if (chickens[i][0] <= -arena_Size / 2) {
        chickens[i][2] = abs(chickens[i][2]);
        chickens[i][0] = -arena_Size / 2;
    }
    if (chickens[i][0] >= arena_Size / 2) {
        chickens[i][2] = -abs(chickens[i][2]);
        chickens[i][0] = arena_Size / 2;
    }
    if (chickens[i][1] <= -arena_Size / 2) {
        chickens[i][3] = abs(chickens[i][3]);
        chickens[i][1] = -arena_Size / 2;
    }
    if (chickens[i][1] >= arena_Size / 2) {
        chickens[i][3] = -abs(chickens[i][3]);
        chickens[i][1] = arena_Size / 2;
    }
};
//Runs from player.
var run_from_player = function(i) {
    //This makes the chicken run in the opposite direction of you if you get too close. Also do this with other players, if you have a player array.
    if (dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) <= 100 & under_tree() === false) {
        if (50 / chickens[i][4] <= 5) {
            chickens[i][2] += (chickens[i][0] + coordinates[0] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 50 / chickens[i][4];
            chickens[i][3] += (chickens[i][1] + coordinates[1] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 50 / chickens[i][4];
        } else {
            chickens[i][2] += (chickens[i][0] + coordinates[0] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 5;
            chickens[i][3] += (chickens[i][1] + coordinates[1] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 5;
        }
    }
};
//Runs from bullet.
var run_from_bullet = function(i) {
    //They run away from bullets. If you have a close hit, they will start to run away from it.
    for (var j = 0; j < bullets.length; j++) {
        if (dist(bullets[j][1], bullets[j][2], chickens[i][0], chickens[i][1]) <= 50 & bullets[j][0] !== mine) {
            if (50 / chickens[i][4] <= 5) {
                chickens[i][2] += (chickens[i][0] + coordinates[0] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 50 / chickens[i][4];
                chickens[i][3] += (chickens[i][1] + coordinates[1] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 50 / chickens[i][4];
            } else {
                chickens[i][2] += (chickens[i][0] + coordinates[0] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 5;
                chickens[i][3] += (chickens[i][1] + coordinates[1] - 200) / dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) * Speed_of_chickens * 5;
            }
        }
        //If you HIT the chicken
        if (dist(bullets[j][1], bullets[j][2], chickens[i][0], chickens[i][1]) <= chickens[i][5] / 2 + 5) {
            chickens[i][4] -= bullets[j][5];
            splat(j);
        }
    }
};
//Moves chicken.
var move_chicken = function(i) {
    chickens[i][0] += chickens[i][2];
    chickens[i][1] += chickens[i][3];
    chickens[i][2] *= 0.9;
    chickens[i][3] *= 0.9;
    if (chickens[i][2] + chickens[i][3] >= 7) {
        var b = chickens[i][2] / (chickens[i][3] + chickens[i][2]);
        chickens[i][2] = b * 7;
        chickens[i][3] = (1 - b) * 7;
    }
};
//Manages chickens
var manage_chickens = function() {
    for (var i = 0; i < chickens.length; i++) {
        if (dist(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 200, 200) <= 400 / guns[current_gun][16]) {
            //Draws the chicken.
            pushMatrix();
            if (chickens[i][3] !== 0 & chickens[i][2] !== 0) {
                translate(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1]);
                rotate(atan2(chickens[i][3], chickens[i][2]));
                translate(-chickens[i][0] - coordinates[0], -chickens[i][1] - coordinates[1]);
            }
            draw_chicken(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], chickens[i][5], abs(chickens[i][3]) + abs(chickens[i][2]), chickens[i][4]);
            popMatrix();
            chicken_health(chickens[i][0] + coordinates[0], chickens[i][1] + coordinates[1], 25, chickens[i][4]);
        }
        constrain_chicken(i);
        move_chicken(i);
        run_from_player(i);
        run_from_bullet(i);
        //This movement is random, like a normal chicken would. Change the 25 to make them more hyperactive or less.
        if (floor(random(0, chickens[i][4] * 2)) === 0) {
            chickens[i][2] += random(-5, 5) * Speed_of_chickens;
            chickens[i][3] += random(-5, 5) * Speed_of_chickens;
        }
        if (chickens[i][4] < 50) {
            chickens[i][4] += 0.025;
        }
        //If chicken dead, spawn the coins!
        if (chickens[i][4] <= 0) {
            for (var c = 0; c < 20; c++) {
                coins.push([chickens[i][0] + random(-15, 15), chickens[i][1] + random(-15, 15)]);
            }
            chickens.splice(i, 1);
            xpw += 5;
        }
    }
};
//Spawns chickens.
var spawn_chickens = function() {
    if (round(random(0, 500)) === 1) {
        chickens.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), 0, 0, 50, random(20, 30)]);
    }
};
//}
//IN PROGRESS: BLOBS
//{
var bleb = function(x, y, s) {
    strokeWeight(s / 10);
    stroke(0, 0, 0, 127.5);
    fill(0, 0, 0);
    rect(x - s / 2, y - s / 2, s, s, s / 2);
    strokeWeight(s / 5);
    stroke(255, 0, 0, 200);
    fill(255, 0, 0);
    ellipse(x + s / 4, y - s / 4, s / 8, s / 8);
    ellipse(x + s / 4, y + s / 4, s / 8, s / 8);
};
var hleb = function(x, y, s) {
    noStroke();
    fill(200, 200, 200);
    rect(x - s / 2, y - s / 2, s, s, s / 2);
    strokeWeight(s / 5);
    stroke(0, 255, 255, 200);
    fill(0, 255, 255);
    ellipse(x + s / 4, y - s / 4, s / 8, s / 8);
    ellipse(x + s / 4, y + s / 4, s / 8, s / 8);
};
var blab = function(x, y, s) {
    strokeWeight(s / 10);
    stroke(0, 0, 0, 127.5);
    fill(0, 0, 0);
    rect(x - s / 2, y - s / 2, s, s, s / 2);
    strokeWeight(s / 5);
    stroke(255, 0, 0, 200);
    fill(255, 0, 0);
    ellipse(x + s / 4, y - s / 4, s / 8, s / 8);
    ellipse(x + s / 4, y + s / 4, s / 8, s / 8);
};
var blobHealth = function(x, y, s, z, m) {
    stroke(255, 255, 255);
    strokeWeight(2.5);
    fill(0, 0, 0, 127.5);
    rect(x - s / 2 - s / 4, y - s, s + s / 2, s / 4, s / 16);
    fill(255 - z * 255 / m, z * 255 / m, 0);
    rect(x - s / 2 - s / 4, y - s, (s + s / 2) * z / m, s / 4, s / 16);
};
var spawnBlob = function() {
    //In order: x, y, size, x-vel, y-vel, health, damage, speed, type, range, health they run from you, health regen, total health, day or night?, money they give.
    if (round(random(0, 500)) === 1 & dn >= 1) {
        blobs.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), 25, 0, 0, 50, 0.25, 0.5, bleb, 300, 25, 0.1, 50, false, 20, 15]);
    }
    if (round(random(0, 5000)) === 1) {
        blobs.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), 25, 0, 0, 50, -0.1, 0.25, hleb, 100, 12.5, 0.05, 50, true, 0, 0]);
    }
    if (round(random(0, 5000)) === 1) {
        blobs.push([random(-arena_Size / 2 + 25, arena_Size / 2 - 25), random(-arena_Size / 2 + 25, arena_Size / 2 - 25), 100, 0, 0, 5000, 0.5, 0.1, blab, 10000, 0, 0.1, 5000, true, 500, 200]);
    }
};
var blobmovement = function(i) {
    if (dn >= 1 || blobs[i][13]) {
        if (round(random(0, 20)) === 1) {
            blobs[i][3] += random(-5, 5) * blobs[i][7];
            blobs[i][4] += random(-5, 5) * blobs[i][7];
        }
        blobs[i][0] += blobs[i][3];
        blobs[i][1] += blobs[i][4];
        blobs[i][3] *= 0.9;
        blobs[i][4] *= 0.9;
    }
};
var constrain_blob = function(i) {
    if (blobs[i][0] <= -arena_Size / 2) {
        blobs[i][3] = abs(blobs[i][3]);
        blobs[i][0] = -arena_Size / 2;
    }
    if (blobs[i][0] >= arena_Size / 2) {
        blobs[i][3] = -abs(blobs[i][3]);
        blobs[i][0] = arena_Size / 2;
    }
    if (blobs[i][1] <= -arena_Size / 2) {
        blobs[i][4] = abs(blobs[i][4]);
        blobs[i][1] = -arena_Size / 2;
    }
    if (blobs[i][1] >= arena_Size / 2) {
        blobs[i][4] = -abs(blobs[i][4]);
        blobs[i][1] = arena_Size / 2;
    }
};
var run_at_player = function(i) {
    if (dn >= 1 || blobs[i][13]) {
        if (dist((blobs[i][0] + coordinates[0]), (blobs[i][1] + coordinates[1]), 200, 200) <= blobs[i][9] & blobs[i][5] >= blobs[i][10]) {
            blobs[i][3] -= (blobs[i][0] + coordinates[0] - 200) / dist(blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1], 200, 200) / 2 * blobs[i][7];
            blobs[i][4] -= (blobs[i][1] + coordinates[1] - 200) / dist(blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1], 200, 200) / 2 * blobs[i][7];
        } else if (dist((blobs[i][0] + coordinates[0]), (blobs[i][1] + coordinates[1]), 200, 200) <= blobs[i][9] & blobs[i][5] <= blobs[i][10] & dn >= 1) {
            blobs[i][3] += (blobs[i][0] + coordinates[0] - 200) / dist(blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1], 200, 200) / 2 * blobs[i][7];
            blobs[i][4] += (blobs[i][1] + coordinates[1] - 200) / dist(blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1], 200, 200) / 2 * blobs[i][7];
        }
        if (dist((blobs[i][0] + coordinates[0]), (blobs[i][1] + coordinates[1]), 200, 200) <= blobs[i][2] / 2 + 12.5) {
            characters[current_character][3] -= blobs[i][6];
        }
    }
};
var hit_by_bullet = function(i) {
    for (var j = 0; j < bullets.length; j++) {
        if (dn >= 1 || blobs[i][13]) {
            if (dist(bullets[j][1], bullets[j][2], blobs[i][0], blobs[i][1]) <= blobs[i][2] / 2 + 5) {
                blobs[i][5] -= bullets[j][5];
                splat(j);
            }
        }
    }
};
var manage_blobs = function() {
    for (var i = 0; i < blobs.length; i++) {
        if (blobs[i][5] <= blobs[i][12] & dn >= 1) {
            blobs[i][5] += blobs[i][11];
        }
        pushMatrix();
        translate((blobs[i][0] + coordinates[0]), (blobs[i][1] + coordinates[1]));
        if (blobs[i][3] !== 0 & blobs[i][4] !== 0) {
            rotate(atan2(blobs[i][4], blobs[i][3]));
        }
        translate(-(blobs[i][0] + coordinates[0]), -(blobs[i][1] + coordinates[1]));
        blobs[i][8](blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1], blobs[i][2], i);
        popMatrix();
        blobHealth(blobs[i][0] + coordinates[0], blobs[i][1] + coordinates[1] - blobs[i][2]/4, blobs[i][2]/2, blobs[i][5], blobs[i][12]);
        blobmovement(i);
        constrain_blob(i);
        run_at_player(i);
        hit_by_bullet(i);
        if (blobs[i][5] <= 0) {
            for (var c = 0; c < blobs[i][14]; c++) {
                coins.push([blobs[i][0] + random(-15, 15), blobs[i][1] + random(-15, 15)]);
            }
            xpw += blobs[i][15];
            blobs.splice(i, 1);
        }
    }
};
//}
//"Splat" graphics
var draw_Splats = function() {
    for (var i = 0; i < splats.length; i++) {
        splats[i][2](splats[i][0] + coordinates[0], splats[i][1] + coordinates[1], 25, "hit", splats[i][3]);
        splats[i][3] *= 0.9;
    }
};
//Crates stuff.
//{
//Spawns crates.
var spawn_Crates = function() {
    if (round(random(0, 250)) === 1) {
        crates.push([round((random(-arena_Size / 2 + 25, arena_Size / 2 - 25)) / 25) * 25, round((random(-arena_Size / 2 + 25, arena_Size / 2 - 25)) / 25) * 25, 100, 100, 10]);
    }
};
//Draws a crate!
var draw_Crate = function(x, y, s, z) {
    fill(0, 0, 0, 100);
    noStroke();
    ellipse(x + 12.5, y + 12.5, 25 * sqrt(2), 25 * sqrt(2));
    noStroke();
    fill(179, 140, 109);
    rect(x - s / 8, y - s / 8, s + s / 4, s + s / 4, s / 4);
    noStroke();
    fill(140, 100, 60);
    rect(x + s / 8, y + s / 8, s - s / 4, s / 4, s / 16);
    rect(x + s / 8, y + s / 2 + s / 8, s - s / 4, s / 4, s / 16);
    rect(x + s / 8, y + s / 8, s / 4, s - s / 4, s / 16);
    rect(x + s / 8 + s / 2, y + s / 8, s / 4, s - s / 4, s / 16);
    stroke(255, 255, 255);
    strokeWeight(2.5);
    fill(0, 0, 0, 127.5);
    rect(x - s / 4, y - s / 2, s + s / 2, s / 4, s / 16);
    fill(255 - crates[z][2] / crates[z][3] * 255, crates[z][2] / crates[z][3] * 255, 0);
    rect(x - s / 4, y - s / 2, (s + s / 2) * crates[z][2] / crates[z][3], s / 4, s / 16);
};
//Dead crates spawn coins.
var dead_crate = function(i) {
    if (crates[i][2] / crates[i][3] <= 0) {
        for (var c = 0; c < crates[i][4]; c++) {
            coins.push([crates[i][0] + random(-15, 15) + 12.5, crates[i][1] + random(-15, 15) + 12.5]);
        }
        crates.splice(i, 1);
        xpw += 2;
        return;
    }
};
//Draws crates.
var draw_Crates = function() {
    for (var i = 0; i < crates.length; i++) {
        draw_Crate(crates[i][0] + coordinates[0], crates[i][1] + coordinates[1], 25, i);
        for (var j = 0; j < bullets.length; j++) {
            if (dist(bullets[j][1] + coordinates[0], bullets[j][2] + coordinates[1], crates[i][0] + coordinates[0] + 12.5, crates[i][1] + coordinates[1] + 12.5) <= 12.5 * sqrt(2)) {
                crates[i][2] -= bullets[j][5];
                splat(j);
            }
        }
        dead_crate(i);
    }
};
var crate_Collision = function() {
    for (var i = 0; i < crates.length; i++) {
        if (side(crates[i][0] + coordinates[0], crates[i][1] + coordinates[1], 187.5, 187.5, 30, 25) === "left") {
            speed[0] = -abs(speed[0]);
        }
        if (side(crates[i][0] + coordinates[0], crates[i][1] + coordinates[1], 187.5, 187.5, 30, 25) === "right") {
            speed[0] = abs(speed[0]);
        }
        if (side(crates[i][0] + coordinates[0], crates[i][1] + coordinates[1], 187.5, 187.5, 30, 25) === "up") {
            speed[1] = -abs(speed[1]);
        }
        if (side(crates[i][0] + coordinates[0], crates[i][1] + coordinates[1], 187.5, 187.5, 30, 25) === "down") {
            speed[1] = abs(speed[1]);
        }
    }
};
//}
//Coin stuff.
//{
var draw_Coin = function(x, y, s) {
    pushMatrix();
    translate(x, y);
    rotate(45);
    translate(-x, -y);
    fill(0, 255, 0);
    stroke(0, 200, 0);
    strokeWeight(s / 4);
    rect(x - s / 2, y - s / 2, s, s);
    popMatrix();
};
var draw_Coins = function() {
    for (var i = 0; i < coins.length; i++) {
        draw_Coin(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 10);
        if (dist(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 200, 200) <= 50) {
            coins[i][0] += (200 - (coins[i][0] + coordinates[0])) / dist(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 200, 200) * 5;
            coins[i][1] += (200 - (coins[i][1] + coordinates[1])) / dist(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 200, 200) * 5;
        }
        if (dist(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 200, 200) <= 16) {
            coins.splice(i, 1);
            money++;
        }
        else if (dist(coins[i][0] + coordinates[0], coins[i][1] + coordinates[1], 200, 200) >= 400) {
            coins.splice(i, 1);
        }
    }
};
//}
//XP bars, health bars, you know.
var bar = function() {
    fill(0, 0, 0, 100);
    rect(0, 312.5, 400, 50, 5);
    for (var i = 0; i < 10; i++) {
        if (i < guns.length) {
            if (guns[i][12] === true) {
                fill(0, 0, 0, 120);
            } else {
                fill(255, 0, 0, 120);
            }
            if (mouseX > 5 + i * 50 & mouseX < 5 + i * 50 + 40 & mouseY > 317.5 & mouseY < 357.5) {
                if (guns[i][12] === false) {
                    textSize(10);
                    textAlign(CENTER, BOTTOM);
                    fill(255, 255, 255, 200);
                    text("Buy for " + guns[i][13], 25 + i * 50, 317.5);
                    draw_Coin(62 + i * 50, 311, 5);
                    if (mouseIsPressed & money >= guns[i][13]) {
                        guns[i][12] = true;
                        money -= guns[i][13];
                    }
                }
                fill(127.5, 127.5, 127.5, 120);
            }
        } else {
            fill(0, 0, 0, 120);
        }
        noStroke();
        if (i === current_gun) {
            strokeWeight(5);
            stroke(255, 255, 255, 127.5);
        }
        rect(5 + i * 50, 317.5, 40, 40, 5);
        if (i < guns.length) {
            guns[i][1](15 + i * 50, 317.5 + 12.5, 40, "gun");
        }
    }
    draw_Coin(387.5, 300, 10);
    draw_wood(380, 270, 15);
    stroke(255, 255, 255);
    strokeWeight(2.5);
    textSize(20);
    fill(255, 255, 255, 200);
    textAlign(RIGHT, CENTER);
    text(money, 375, 300);
    text(woods, 375, 277.5);
    textAlign(LEFT, TOP);
    text("FPS: " + round(this.__frameRate)+"\nTime: "+round(frameCount/100), 2.5, 0);
    fill(0, 0, 0, 127.5);
    rect(25, 375, 350, 12.5, 25);
    fill(255 - 255 * characters[current_character][3] / characters[current_character][4], 255 * characters[current_character][3] / characters[current_character][4], 0);
    rect(25, 375, 350 * characters[current_character][3] / characters[current_character][4], 12.5, 25);
    fill(0, 0, 0, 127.5);
    rect(375, 25, 12.5, 200, 5);
    fill(0, 255, 255, 127.5);
    rect(375, 25, 12.5, constrain(xpw / next_xp * 200, 0, 200), 5);
    stroke(255, 255, 255);
    strokeWeight(2.5);
    fill(0, 255, 255);
    rect(375, 25, 12.5, constrain(xp / next_xp * 200, 0, 200), 5);
    fill(0, 255, 255, 255);
    textAlign(RIGHT, CENTER);
    textSize(12.5);
    text(tiers[constrain(tier, 0, tiers.length - 1)], 395, 12.5);
};
//Night graphics
var nightime = function() {
    if (night === true) {
        fill(0, 0, 0, 0);
        strokeWeight(12.75);
        for (var i = 0; i < 570; i += 25) {
            stroke(0, 0, 0, i * 4 / 5 * constrain(dn, 0, 1));
            ellipse(200, 200, i, i);
            stroke(255, 255, 0, (570/2-i) * 4 / 5 * constrain(dn, 0, 1)/1.5);
            ellipse(200, 200, i+50, i+50);
        }
    }
    dn += ss;
    if (dn >= 20) {
        ss = -0.01;
    }
    if (dn <= -19) {
        ss = 0.01;
    }
};
var manage_zoom = function() {
    if(guns[current_gun][16] <= guns[current_gun][17]) {
        guns[current_gun][16] = guns[current_gun][17];
    }
};
var hack = function() {
    if(hacked === true) {
        guns = [
            [25, pistol, 1000000000, 0, 0, 10, 1000000000, 1, 0, 12.5, 0, 0, true, 0, 250, 20, 0.5, 1],
            [62.5, machine, 100000000000000000, 0, 0, 8, 1000000000000, 2, 0, 2, 0, 0, true, 300, 300, 40, 0.5, 0.9],
            [75, cannon, 30000000000000, 0, 0, 6, 30000000000000000, 0, 0, 25, 75, 37.5, true, 500, 400, 25, 0.5, 1],
            [62.5, sniper, 1000000000000000, 0, 0, 20, 10000000000000, 0, 0, 40, 0, 0, true, 500, 200, 100, 0.5, 0.5],
            [50, fume, 150000000000000, 0, 0, 2, 15000000000, 1.25, 0, 0.1, 0, 0, true, 400, 100, 1000, 0.5, 1],
            [50, water, 200000000000000000, 0, 0, 4, 200, 0.5, 0, 2, 25, 1, true, 400, 100, 40, 0.5, 0.9],
            [50, mine, 100000000000000000, 0, 0, 0, 10, 0, 0, 5, 50, 50, true, 400, 100, 1000, 0.5, 0.9],
            [50, shock, 800000000000, 0, 0, 10, 8, 0.1, 0, 2.5, 100, 12.5, true, 600, 300, 30, 0.5, 0.75]
        ];
        characters[current_character][3] = 100000;
    }
    var characters = [
    [25, basic, 2.5, 100, 100, 1],
    [25, ghost, 3, 75, 75, 2.5],
    [25, camo, 1, 150, 150, 1]
];
};
mouseClicked = function() {
    if(mouseButton === CENTER) {
        hacked = true;
        coins = [];
        bullets = [];
        
    }
};
//Draw function, holds everything.
draw = function() {
    pushMatrix();
    translate(200, 200);
    scale(guns[current_gun][16]);
    translate(-200, -200);
    grid();
    move();
    manage_health();
    manage_gun_reload();
    shoot();
    load();
    spawn_Crates();
    draw_Crates();
    draw_Coins();
    manage_bullets();
    draw_Splats();
    manage_chickens();
    spawn_chickens();
    spawnBlob();
    manage_blobs();
    draw_Character();
    manage_rocks();
    manage_trees();
    manage_wood();
    popMatrix();
    nightime();
    redden();
    bar();
    manage_xp();
    crate_Collision();
    manage_zoom();
    hack();
};
//Key pressed things for movement/reload and stuff.
keyPressed = function() {
    if (keyCode === UP || String(key) === 'w' & speed[1] < characters[current_character][2]) {
        movement[0] = true;
    }
    if (keyCode === LEFT || String(key) === 'a' & speed[0] < characters[current_character][2]) {
        movement[1] = true;
    }
    if (keyCode === DOWN || String(key) === 's' & speed[1] > -characters[current_character][2]) {
        movement[2] = true;
    }
    if (keyCode === RIGHT || String(key) === 'd' & speed[0] > -characters[current_character][2]) {
        movement[3] = true;
    }
    if (String(key) === "r" & guns[current_gun][2] < guns[current_gun][6]) {
        loading = true;
    }
    if (String(key) === "-") {
        if (guns[current_gun][16] > guns[current_gun][17]) {
            guns[current_gun][16] -= 0.05;
        }
    }
    if (String(key) === "=") {
        if (guns[current_gun][16] < 1) {
            guns[current_gun][16] += 0.05;
        }
    }
};
//Key released things.
keyReleased = function() {
    if (keyCode === UP || String(key) === 'w') {
        movement[0] = false;
    }
    if (keyCode === LEFT || String(key) === 'a') {
        movement[1] = false;
    }
    if (keyCode === DOWN || String(key) === 's') {
        movement[2] = false;
    }
    if (keyCode === RIGHT || String(key) === 'd') {
        movement[3] = false;
    }
    if (String(key) === "o") {
        characters[current_character][3] = characters[current_character][4];
        coordinates = [200, 200];
    }
    if (parseInt(String(key), 10) >= 1 & parseInt(String(key), 10) <= guns.length & guns[parseInt(String(key), 10) - 1][12] === true) {
        current_gun = parseInt(String(key), 10) - 1;
    }
};
mouseScrolled = function() {
    if (guns[current_gun][16] > guns[current_gun][17] & mouseScroll <= 0) {
        guns[current_gun][16] += mouseScroll / 25;
    }
    if (guns[current_gun][16] < 1 & mouseScroll >= 0) {
        guns[current_gun][16] += mouseScroll / 25;
    }
};
if(I_agree === false) {
    throw {
        message: "To play the game, you must consent to the terms given at the top of the code."
    };
}
//}
/////////////////
    }
});
        </script>
        <button onclick="window.location.href='index.html';" class="back-button">Back to Main Page</button>
    </body>
</html>